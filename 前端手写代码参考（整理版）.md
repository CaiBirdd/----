# 前端面试手写代码参考（整理版）

> 目标：把常见手写题按“考点”归类，便于快速复习与背诵。
>
> 说明：本整理版会**修正原文中少量明显错误/笔误**（例如 `debounce` 的清理、`Promise.all` 的返回值、`arrToTree` 的 children 赋值、斐波那契里把比较写成赋值等）。

## 重要性标记说明

- 【必会】：出现概率极高；不熟容易直接扣分。
- 【高频】：经常考；建议能默写并讲清关键点。
- 【中频】：偶尔考；至少要能写出思路或“半成品”。
- 【低频】：加分项；面试前期可暂缓，冲刺再补。

## 目录

- [1. 对象与原型链](#1-对象与原型链)
  - [1.1 手写 new](#11-手写-new) 【必会】
  - [1.2 手写 instanceof](#12-手写-instanceof) 【必会】
  - [1.3 手写 Object.create](#13-手写-objectcreate) 【高频】
- [2. this 绑定：call / apply / bind](#2-this-绑定call--apply--bind)
  - [2.1 myCall](#21-mycall) 【必会】
  - [2.2 myApply](#22-myapply) 【必会】
  - [2.3 myBind（简版）](#23-mybind简版) 【必会】
- [3. 高频工具函数](#3-高频工具函数)
  - [3.1 节流 throttle](#31-节流-throttle) 【必会】
  - [3.2 防抖 debounce](#32-防抖-debounce) 【必会】
  - [3.3 浅拷贝 shallowClone](#33-浅拷贝-shallowclone) 【高频】
  - [3.4 深拷贝 deepClone（处理循环引用）](#34-深拷贝-deepclone处理循环引用) 【必会】
  - [3.5 数字千分位格式化](#35-数字千分位格式化) 【中频】
- [4. 函数式：柯里化与链式调用](#4-函数式柯里化与链式调用)
  - [4.1 curry（按形参个数收集）](#41-curry按形参个数收集) 【高频】
  - [4.2 add(1)(2)(3)（不定长收集）](#42-add123不定长收集) 【中频】
- [5. 异步与定时器](#5-异步与定时器)
  - [5.1 每隔 1 秒打印 1,2,3,4](#51-每隔-1-秒打印-1234) 【中频】
  - [5.2 用 setTimeout 实现 setInterval](#52-用-settimeout-实现-setinterval) 【中频】
- [6. Promise 手写核心（面试常问）](#6-promise-手写核心面试常问)
  - [6.1 MyPromise（简化版：then + 解析过程）](#61-mypromise简化版then--解析过程) 【高频】
  - [6.2 Promise.resolve / all / race](#62-promiseresolve--all--race) 【高频】
- [7. 数组与数据结构题](#7-数组与数据结构题)
  - [7.1 数组扁平化 flatten](#71-数组扁平化-flatten) 【高频】
  - [7.2 数组去重 unique](#72-数组去重-unique) 【高频】
  - [7.3 手写 reduce](#73-手写-reduce) 【中频】
  - [7.4 手写 push / filter / map](#74-手写-push--filter--map) 【中频】
  - [7.5 数组转树 arrToTree](#75-数组转树-arrtotree) 【高频】
  - [7.6 树转数组 treeToArr](#76-树转数组-treetoarr) 【中频】
- [8. 算法：斐波那契与排序](#8-算法斐波那契与排序)
  - [8.1 斐波那契 fibonacci](#81-斐波那契-fibonacci) 【中频】
  - [8.2 排序算法合集](#82-排序算法合集) 【中频】
- [9. 设计模式：发布-订阅](#9-设计模式发布-订阅) 【高频】

---

## 1. 对象与原型链

### 1.1 手写 new

> 重要性：【必会】（原型链 + 构造流程是 JS 基础核心）

- 关键点：`Object.create(fn.prototype)` + `fn.apply(obj, args)` + “构造函数返回对象则替换返回值”

考点：
- `new` 会做什么（创建对象、链接原型、绑定 this、处理返回值）。

```js
function myNew(fn, ...args) {
  if (typeof fn !== 'function') {
    throw new TypeError('fn must be a function')
  }

  const obj = Object.create(fn.prototype)
  const result = fn.apply(obj, args)

  const isObjectLike = result !== null && (typeof result === 'object' || typeof result === 'function')
  return isObjectLike ? result : obj
}
```

### 1.2 手写 instanceof

> 重要性：【必会】（原型链判断的经典题）

- 关键点：`Object.getPrototypeOf` 向上遍历原型链，逐层对比 `constructor.prototype`

考点：
- 沿着原型链向上找，判断是否能遇到 `constructor.prototype`。

```js
function myInstanceof(obj, constructor) {
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) return false

  let proto = Object.getPrototypeOf(obj)
  while (proto) {
    if (proto === constructor.prototype) return true
    proto = Object.getPrototypeOf(proto)
  }
  return false
}
```

### 1.3 手写 Object.create

> 重要性：【高频】（常作为原型链题的配套/延伸）

- 关键点：把 `proto` 挂到临时构造函数的 `prototype` 上，再 `new` 出实例

```js
function myCreate(proto) {
  function F() {}
  F.prototype = proto
  return new F()
}
```

---

## 2. this 绑定：call / apply / bind

> 注意：面试写法通常用 `Symbol` 避免覆盖对象原属性。

### 2.1 myCall

> 重要性：【必会】（this 绑定三件套之一，面试常追问实现细节）

- 关键点：`context == null ? globalThis : Object(context)` + `Symbol` 防覆盖 + 执行后清理

```js
Function.prototype.myCall = function (context, ...args) {
  if (typeof this !== 'function') throw new TypeError('myCall must be called on a function')

  const ctx = context == null ? globalThis : Object(context)
  const key = Symbol('fn')
  ctx[key] = this
  const result = ctx[key](...args)
  delete ctx[key]
  return result
}
```

### 2.2 myApply

> 重要性：【必会】（与 call 成对出现，差异点必须说清）

- 关键点：与 `call` 的唯一区别：第二参是数组（或类数组）并用展开传入

```js
Function.prototype.myApply = function (context, args) {
  if (typeof this !== 'function') throw new TypeError('myApply must be called on a function')

  const ctx = context == null ? globalThis : Object(context)
  const key = Symbol('fn')
  ctx[key] = this
  const result = Array.isArray(args) ? ctx[key](...args) : ctx[key]()
  delete ctx[key]
  return result
}
```

### 2.3 myBind（简版）

> 重要性：【必会】（高频：闭包保存参数；进阶：支持 new 调用）

- 关键点：返回新函数 + 合并两次参数；进阶必讲：`new` 调用时 this 绑定规则不同

> 完整版 `bind` 还要处理：作为构造函数 `new` 调用时，忽略绑定的 `this`。

```js
Function.prototype.myBind = function (context, ...args1) {
  if (typeof this !== 'function') throw new TypeError('myBind must be called on a function')

  const fn = this
  return function (...args2) {
    return fn.apply(context, [...args1, ...args2])
  }
}
```

---

## 3. 高频工具函数

### 3.1 节流 throttle

> 重要性：【必会】（与防抖并列，几乎必考）

- 关键点：用时间戳/定时器限制触发频率；本实现用 `now - last >= wait`

定义：在 `wait` 时间内最多执行一次。

```js
function throttle(fn, wait) {
  let last = 0
  return function (...args) {
    const now = Date.now()
    if (now - last >= wait) {
      last = now
      return fn.apply(this, args)
    }
  }
}
```

### 3.2 防抖 debounce

> 重要性：【必会】（必考；还可能追问 immediate/取消/返回值）

- 关键点：每次触发先 `clearTimeout`，再重新 `setTimeout`；`immediate` 走“第一次立刻执行”分支

定义：停止触发 `wait` ms 后才执行；若持续触发则重置计时。

> 原文中用 `clearInterval` 清理 `setTimeout`，这里修正为 `clearTimeout`。

```js
function debounce(fn, wait, immediate = false) {
  let timer = null

  return function (...args) {
    if (timer) {
      clearTimeout(timer)
      timer = null
    }

    if (immediate) {
      const shouldCallNow = !timer
      timer = setTimeout(() => {
        timer = null
      }, wait)
      if (shouldCallNow) return fn.apply(this, args)
    } else {
      timer = setTimeout(() => {
        fn.apply(this, args)
      }, wait)
    }
  }
}
```

### 3.3 浅拷贝 shallowClone

> 重要性：【高频】（常用于引出深拷贝、引用类型/浅拷贝坑）

- 关键点：只复制一层；引用类型属性仍共享同一地址

```js
function shallowClone(obj) {
  if (obj === null || typeof obj !== 'object') return obj

  const res = Array.isArray(obj) ? [] : {}
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      res[key] = obj[key]
    }
  }
  return res
}
```

### 3.4 深拷贝 deepClone（处理循环引用）

> 重要性：【必会】（循环引用 + 引用类型是高频考点）

- 关键点：`Map` 记忆化（`cache.has/set`）解决循环引用；递归时注意 `null`

```js
function deepClone(obj, cache = new Map()) {
  if (obj === null || typeof obj !== 'object') return obj

  if (cache.has(obj)) return cache.get(obj)

  const res = Array.isArray(obj) ? [] : {}
  cache.set(obj, res)

  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key]
      res[key] = typeof value === 'object' && value !== null ? deepClone(value, cache) : value
    }
  }

  return res
}
```

### 3.5 数字千分位格式化

> 重要性：【中频】（工具题，适合面试热身/加分）

- 关键点：整数部分用正则插入逗号；小数部分原样拼回

```js
function formatThousands(num) {
  if (typeof num !== 'number' || Number.isNaN(num)) return num

  const [intPart, decPart] = String(num).split('.')
  const intFormatted = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  return decPart ? `${intFormatted}.${decPart}` : intFormatted
}
```

---

## 4. 函数式：柯里化与链式调用

### 4.1 curry（按形参个数收集）

> 重要性：【高频】（函数式常考，能写出收参/递归思路即可）

- 关键点：用 `fn.length` 决定“收集到多少参数才执行”，不足则返回新函数继续收集

```js
function curry(fn, args = []) {
  const arity = fn.length
  return function (...nextArgs) {
    const allArgs = [...args, ...nextArgs]
    if (allArgs.length >= arity) {
      return fn.apply(this, allArgs)
    }
    return curry(fn, allArgs)
  }
}
```

### 4.2 add(1)(2)(3)（不定长收集）

> 重要性：【中频】（链式调用 + 隐式转换；属于加分题）

- 关键点：闭包累加 + 重写 `valueOf/toString` 让它在打印/运算时输出最终值

考点：链式调用 + 隐式转换（`valueOf` / `toString`）。

```js
function add(...initial) {
  let sum = initial.reduce((a, b) => a + b, 0)

  function inner(...next) {
    sum += next.reduce((a, b) => a + b, 0)
    return inner
  }

  inner.valueOf = () => sum
  inner.toString = () => String(sum)
  return inner
}

// 用法：
// +add(1)(2)(3) === 6
// String(add(1)(2)(3)) === '6'
```

---

## 5. 异步与定时器

### 5.1 每隔 1 秒打印 1,2,3,4

> 重要性：【中频】（闭包/作用域经典题，常考 let vs var）

- 关键点：`let` 形成块级作用域；每次循环都有独立的 `i`

考点：闭包/作用域；`let` 的块级作用域。

```js
for (let i = 1; i <= 4; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 1000)
}
```

### 5.2 用 setTimeout 实现 setInterval

> 重要性：【中频】（定时器机制理解题，常追问漂移与清理）

- 关键点：递归 `setTimeout`；提供 `clear()` 终止后续调度

```js
function mySetInterval(fn, delay) {
  let timerId = null
  let stopped = false

  function tick() {
    if (stopped) return
    fn()
    timerId = setTimeout(tick, delay)
  }

  timerId = setTimeout(tick, delay)

  return {
    clear() {
      stopped = true
      if (timerId) clearTimeout(timerId)
      timerId = null
    },
  }
}
```

---

## 6. Promise 手写核心（面试常问）

> 说明：Promise/A+ 完整实现很长，这里保留面试最常写到的骨架与关键点：
> - 状态机（pending/fulfilled/rejected）
> - then 的链式返回（返回新 Promise）
> - 解析过程（处理 thenable、避免循环引用、只调用一次）

### 6.1 MyPromise（简化版：then + 解析过程）

> 重要性：【高频】（大厂/中高级更常见；核心是 then 链与 thenable 解析）

- 关键点：`then` 必须返回新 Promise；`_resolvePromise` 处理 thenable、避免循环引用、确保只调用一次

```js
class MyPromise {
  constructor(executor) {
    this.state = 'pending'
    this.value = undefined
    this.reason = undefined

    this.onFulfilledCallbacks = []
    this.onRejectedCallbacks = []

    const resolve = (value) => {
      if (this.state !== 'pending') return
      this.state = 'fulfilled'
      this.value = value
      this.onFulfilledCallbacks.forEach((fn) => fn())
    }

    const reject = (reason) => {
      if (this.state !== 'pending') return
      this.state = 'rejected'
      this.reason = reason
      this.onRejectedCallbacks.forEach((fn) => fn())
    }

    try {
      executor(resolve, reject)
    } catch (e) {
      reject(e)
    }
  }

  then(onFulfilled, onRejected) {
    const realOnFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (v) => v
    const realOnRejected =
      typeof onRejected === 'function'
        ? onRejected
        : (e) => {
            throw e
          }

    const p2 = new MyPromise((resolve, reject) => {
      const runFulfilled = () => {
        setTimeout(() => {
          try {
            const x = realOnFulfilled(this.value)
            MyPromise._resolvePromise(p2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        }, 0)
      }

      const runRejected = () => {
        setTimeout(() => {
          try {
            const x = realOnRejected(this.reason)
            MyPromise._resolvePromise(p2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        }, 0)
      }

      if (this.state === 'fulfilled') runFulfilled()
      else if (this.state === 'rejected') runRejected()
      else {
        this.onFulfilledCallbacks.push(runFulfilled)
        this.onRejectedCallbacks.push(runRejected)
      }
    })

    return p2
  }

  static _resolvePromise(p2, x, resolve, reject) {
    if (p2 === x) return reject(new TypeError('Chaining cycle detected'))

    let called = false

    if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
      try {
        const then = x.then
        if (typeof then === 'function') {
          then.call(
            x,
            (y) => {
              if (called) return
              called = true
              MyPromise._resolvePromise(p2, y, resolve, reject)
            },
            (r) => {
              if (called) return
              called = true
              reject(r)
            },
          )
        } else {
          resolve(x)
        }
      } catch (e) {
        if (called) return
        called = true
        reject(e)
      }
    } else {
      resolve(x)
    }
  }
}
```

### 6.2 Promise.resolve / all / race

> 重要性：【高频】（`all/race` 非常常考；能处理顺序/短路/空数组）

- 关键点：`all` 需按 index 保序并等全部完成；`race` 谁先 settle 就用谁

> 原文中 `all` 最后 `resolve(array)` 是错误的（应返回收集的 `result`）。这里修正。

```js
MyPromise.resolve = function (value) {
  if (value instanceof MyPromise) return value
  return new MyPromise((resolve) => resolve(value))
}

MyPromise.all = function (iterable) {
  return new MyPromise((resolve, reject) => {
    if (!Array.isArray(iterable)) return reject(new TypeError('all expects an array'))

    const results = []
    let finished = 0

    if (iterable.length === 0) return resolve([])

    iterable.forEach((p, index) => {
      MyPromise.resolve(p).then(
        (value) => {
          results[index] = value
          finished++
          if (finished === iterable.length) resolve(results)
        },
        (err) => reject(err),
      )
    })
  })
}

MyPromise.race = function (iterable) {
  return new MyPromise((resolve, reject) => {
    if (!Array.isArray(iterable)) return reject(new TypeError('race expects an array'))

    iterable.forEach((p) => {
      MyPromise.resolve(p).then(resolve, reject)
    })
  })
}
```

---

## 7. 数组与数据结构题

### 7.1 数组扁平化 flatten

> 重要性：【高频】（递归/栈的典型题，常与深拷贝一起出现）

- 关键点：递归版最稳；栈版注意 `pop` 导致顺序问题（可 `reverse()`）

**递归版（最常写）**

```js
function flatten(arr) {
  const res = []
  for (const item of arr) {
    if (Array.isArray(item)) res.push(...flatten(item))
    else res.push(item)
  }
  return res
}
```

**栈版（注意顺序）**：如果用 `pop`，结果可能是反序，需要 `reverse()`。

```js
function flattenWithStack(arr) {
  const stack = [...arr]
  const res = []

  while (stack.length) {
    const next = stack.pop()
    if (Array.isArray(next)) stack.push(...next)
    else res.push(next)
  }

  return res.reverse()
}
```

**ES6（反复拍平一层）**

```js
function flattenES6(arr) {
  while (arr.some(Array.isArray)) {
    arr = [].concat(...arr)
  }
  return arr
}
```

### 7.2 数组去重 unique

> 重要性：【高频】（Set/Map/对象哈希的取舍与坑点）

- 关键点：`Set` 最简单；`indexOf`/哈希方案要注意 `NaN`、对象引用、类型区分

```js
const unique1 = (arr) => [...new Set(arr)]

const unique2 = (arr) => arr.filter((item, idx) => arr.indexOf(item) === idx)

function unique3(arr) {
  const seen = Object.create(null)
  const res = []
  for (const item of arr) {
    const key = typeof item + ':' + String(item)
    if (!seen[key]) {
      seen[key] = true
      res.push(item)
    }
  }
  return res
}
```

### 7.3 手写 reduce

> 重要性：【中频】（数组 API 题，主要看边界：初始值/空数组）

- 关键点：`initialValue` 是否传入决定起始下标与初始累加器

```js
function myReduce(arr, callback, initialValue) {
  const hasInit = initialValue !== undefined
  let acc = hasInit ? initialValue : arr[0]
  let i = hasInit ? 0 : 1

  for (; i < arr.length; i++) {
    acc = callback(acc, arr[i], i, arr)
  }
  return acc
}
```

### 7.4 手写 push / filter / map

> 重要性：【中频】（API 实现题，更多考循环/回调/返回值约定）

- 关键点：按规范传参（value/index/array）；`push` 返回新长度，`filter/map` 返回新数组

```js
Array.prototype.myPush = function (...items) {
  for (let i = 0; i < items.length; i++) {
    this[this.length] = items[i]
  }
  return this.length
}

Array.prototype.myFilter = function (callback) {
  if (typeof callback !== 'function') throw new TypeError('callback must be a function')

  const res = []
  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i, this)) res.push(this[i])
  }
  return res
}

Array.prototype.myMap = function (callback) {
  if (typeof callback !== 'function') throw new TypeError('callback must be a function')

  const res = []
  for (let i = 0; i < this.length; i++) {
    res.push(callback(this[i], i, this))
  }
  return res
}
```

### 7.5 数组转树 arrToTree

> 重要性：【高频】（业务场景强：菜单/权限/组织架构）

- 关键点：先用 `Map` 缓存 id->node，再二次遍历挂到 `parent.children`

考点：`id/pid` 结构、哈希表加速、引用复用。

```js
function arrToTree(list, rootPid = 0) {
  const map = new Map()
  const result = []

  for (const item of list) {
    map.set(item.id, { ...item })
  }

  for (const item of list) {
    const node = map.get(item.id)
    if (item.pid === rootPid) {
      result.push(node)
    } else {
      const parent = map.get(item.pid)
      if (parent) {
        parent.children = parent.children || []
        parent.children.push(node)
      }
    }
  }

  return result
}
```

### 7.6 树转数组 treeToArr

> 重要性：【中频】（与数组转树成对出现；BFS/DFS 思路都可）

- 关键点：队列 BFS（或栈 DFS）；输出时通常要去掉 `children`

```js
function treeToArr(tree) {
  const queue = [...tree]
  const res = []

  while (queue.length) {
    const node = queue.shift()
    const { children, ...rest } = node

    if (Array.isArray(children) && children.length) {
      queue.push(...children)
    }

    res.push(rest)
  }

  return res
}
```

---

## 8. 算法：斐波那契与排序

### 8.1 斐波那契 fibonacci

> 重要性：【中频】（递归 vs 迭代、复杂度与优化思路）

- 关键点：递归要讲复杂度高；迭代用两个变量滚动更新

> 原文中把 `if (n = 0)` 写成了赋值，这里修正。

**递归版**（面试能写但要说明复杂度高）

```js
function fibRecursive(n) {
  if (n === 0) return 0
  if (n === 1) return 1
  return fibRecursive(n - 1) + fibRecursive(n - 2)
}
```

**迭代版**（更推荐）

```js
function fib(n) {
  if (n === 0) return 0
  if (n === 1) return 1

  let a = 0
  let b = 1
  for (let i = 2; i <= n; i++) {
    const c = a + b
    a = b
    b = c
  }
  return b
}
```

### 8.2 排序算法合集

> 重要性：【中频】（常考 1~2 个即可：快排/归并优先；其余多为加分）

建议按面试优先级掌握：
- 【高频】快速排序、归并排序
- 【中频】冒泡排序、插入排序、选择排序
- 【低频】希尔排序、堆排序、计数/桶/基数排序

```js
// 冒泡 O(n^2)
function bubbleSort(arr) {
  const a = arr.slice()
  for (let i = 0; i < a.length - 1; i++) {
    for (let j = 0; j < a.length - i - 1; j++) {
      if (a[j] > a[j + 1]) [a[j], a[j + 1]] = [a[j + 1], a[j]]
    }
  }
  return a
}

// 选择 O(n^2)
function selectionSort(arr) {
  const a = arr.slice()
  for (let i = 0; i < a.length - 1; i++) {
    let min = i
    for (let j = i + 1; j < a.length; j++) {
      if (a[j] < a[min]) min = j
    }
    if (min !== i) [a[i], a[min]] = [a[min], a[i]]
  }
  return a
}

// 插入 O(n^2)
function insertionSort(arr) {
  const a = arr.slice()
  for (let i = 1; i < a.length; i++) {
    const cur = a[i]
    let j = i - 1
    while (j >= 0 && a[j] > cur) {
      a[j + 1] = a[j]
      j--
    }
    a[j + 1] = cur
  }
  return a
}

// 希尔（取决于 gap）
function shellSort(arr) {
  const a = arr.slice()
  for (let gap = Math.floor(a.length / 2); gap > 0; gap = Math.floor(gap / 2)) {
    for (let i = gap; i < a.length; i++) {
      const temp = a[i]
      let j = i
      while (j >= gap && a[j - gap] > temp) {
        a[j] = a[j - gap]
        j -= gap
      }
      a[j] = temp
    }
  }
  return a
}

// 归并 O(n log n)
function mergeSort(arr) {
  if (arr.length <= 1) return arr
  const mid = Math.floor(arr.length / 2)
  const left = mergeSort(arr.slice(0, mid))
  const right = mergeSort(arr.slice(mid))
  return merge(left, right)
}

function merge(left, right) {
  const res = []
  let i = 0
  let j = 0
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) res.push(left[i++])
    else res.push(right[j++])
  }
  return res.concat(left.slice(i)).concat(right.slice(j))
}

// 快排（非原地版本）平均 O(n log n)
function quickSort(arr) {
  if (arr.length <= 1) return arr
  const pivot = arr[0]
  const left = []
  const right = []
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) left.push(arr[i])
    else right.push(arr[i])
  }
  return quickSort(left).concat(pivot, quickSort(right))
}

// 堆排序 O(n log n)
function heapSort(arr) {
  const a = arr.slice()
  const n = a.length

  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(a, n, i)
  for (let i = n - 1; i > 0; i--) {
    ;[a[0], a[i]] = [a[i], a[0]]
    heapify(a, i, 0)
  }
  return a
}

function heapify(a, n, i) {
  let largest = i
  const l = 2 * i + 1
  const r = 2 * i + 2
  if (l < n && a[l] > a[largest]) largest = l
  if (r < n && a[r] > a[largest]) largest = r
  if (largest !== i) {
    ;[a[i], a[largest]] = [a[largest], a[i]]
    heapify(a, n, largest)
  }
}

// 计数排序（适合整数且范围不大）
function countingSort(arr) {
  if (arr.length <= 1) return arr
  const min = Math.min(...arr)
  const max = Math.max(...arr)
  const count = new Array(max - min + 1).fill(0)
  for (const v of arr) count[v - min]++

  const res = []
  for (let i = 0; i < count.length; i++) {
    while (count[i]--) res.push(i + min)
  }
  return res
}

// 桶排序（简单版）
function bucketSort(arr, bucketSize = 5) {
  if (arr.length === 0) return []
  const min = Math.min(...arr)
  const max = Math.max(...arr)
  const bucketCount = Math.floor((max - min) / bucketSize) + 1
  const buckets = Array.from({ length: bucketCount }, () => [])

  for (const v of arr) {
    const idx = Math.floor((v - min) / bucketSize)
    buckets[idx].push(v)
  }

  const res = []
  for (const b of buckets) {
    const sorted = insertionSort(b)
    res.push(...sorted)
  }
  return res
}

// 基数排序（非负整数）
function radixSort(arr) {
  let a = arr.slice()
  const maxDigits = Math.max(0, ...a.map((v) => String(v).length))

  for (let d = 0; d < maxDigits; d++) {
    const buckets = Array.from({ length: 10 }, () => [])
    for (const v of a) {
      const digit = Math.floor(Math.abs(v) / Math.pow(10, d)) % 10
      buckets[digit].push(v)
    }
    a = buckets.flat()
  }

  return a
}
```

---

## 9. 设计模式：发布-订阅

> 重要性：【高频】（事件模型/解耦常用；常追问一次订阅、取消订阅）

- 关键点：`events[event]` 存回调数组；取消订阅用 `findIndex/splice`；触发时遍历执行

> 原文 `unSubscribe` 里判断索引的逻辑写反了，这里修正。

```js
class EventCenter {
  constructor() {
    this.events = Object.create(null)
  }

  subscribe(eventName, callback) {
    if (!this.events[eventName]) this.events[eventName] = []
    this.events[eventName].push(callback)
  }

  unSubscribe(eventName, callback) {
    const list = this.events[eventName]
    if (!list) return

    if (!callback) {
      delete this.events[eventName]
      return
    }

    const idx = list.findIndex((fn) => fn === callback)
    if (idx === -1) return

    list.splice(idx, 1)
    if (list.length === 0) delete this.events[eventName]
  }

  dispatch(eventName, ...args) {
    const list = this.events[eventName]
    if (!list) return
    list.forEach((fn) => fn(...args))
  }
}
```
